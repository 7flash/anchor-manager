import 'dart:convert';

import 'dart:typed_data';

import 'package:http/http.dart' show post;

import 'package:eosdart/eosdart.dart'
    show Block, EOSClient, NodeInfo, Transaction;

import 'package:eosdart_ecc/eosdart_ecc.dart' show EOSPrivateKey, EOSPublicKey;

import 'package:dart_esr/dart_esr.dart'
    show
        Authorization,
        ChainName,
        CallbackPayload,
        ESRConstants,
        ResolvedSigningRequest,
        SigningRequestManager,
        TransactionContext,
        defaultSigningRequestEncodingOptions;

import 'package:cryptography/cryptography.dart';

import 'package:web_socket_channel/io.dart';

import 'package:eosdart/src/serialize.dart' show stringToHex, arrayToHex;

class AnchorConstants {
  static const exampleUri =
      "esr:gmN0S9_Eeqy57zv_9xn9eU3hL_bxCbUs-jptJqsXY3-JtawgA8OyJhPmVwahDAwM4bo2Z88yMjJAAIy2hTEUlk659XTlBC8YnyXExz8YSMuk5qXkFxWnKqSkJqfmlWSW5hoZGemnpaam6OamMllnlJQUFFvp6ycn6SXmJWfkF-nlZOZl6yenmZgYJyUm6pokJxvpmqSaGupaJlsm6xqkplqkWlqYWxiZmDMAAA";
  static const nodeEndpoint = "https://node.hypha.earth";
}

class AnchorDapp {
  final options = defaultSigningRequestEncodingOptions(
    nodeUrl: AnchorConstants.nodeEndpoint,
  );

  Future<String> transact(esrUri) async {
    final request = SigningRequestManager.from(
      esrUri,
      options: options,
    );

    final callbackUrl = request.data.callback;

    final socketUrl = callbackUrl.replaceFirst("http", "ws");

    print("connected $socketUrl");

    final channel = IOWebSocketChannel.connect(socketUrl);

    final event = await channel.stream.first;

    print("received response on channel $callbackUrl");

    final data = jsonDecode(String.fromCharCodes(event));

    print("payload data: " + data);

    final payload = CallbackPayload(
      sa: data["sa"],
      sp: data["sp"],
      sig: data["sig"],
      tx: data["tx"],
      rbn: data["rbn"],
      rid: data["rid"],
      ex: data["ex"],
      req: data["req"],
    );

    final resolved = await ResolvedSigningRequest.fromPayload(payload, options);

    final transaction = Transaction.fromJson(resolved.transaction.toJson());

    final signature = data["sig"];

    final response = await post(
      Uri.parse("${AnchorLink.telosEndpoint}/v1/chain/push_transaction"),
      body: json.encode(
        {
          "signatures": resolved.transaction.signatures,
          "compression": 0,
          "packed_context_free_data": "",
          "packed_trx": arrayToHex(resolved.serializedTransaction),
        },
      ),
    );

    if (response.statusCode >= 300) {
      throw response.body;
    } else {
      return json.decode(response.body);
    }
  }
}

class AnchorWallet {
  Future<String> resolve(esrUri) async {
    // final request = SigningRequestManager.from(
    //   esrUri,
    //   options: defaultSigningRequestEncodingOptions(
    //     nodeUrl: AnchorConstants.nodeEndpoint,
    //   ),
    // );

    // final callbackUrl = request.data.callback;

    print("TESTING");
    return "null";

    // final response = await post(
    //   Uri.parse(callbackUrl), body: jsonEncode({}),
    // body: jsonEncode({
    //   "sa": request.data.req.toString(),
    //   "sp": request.data.req["sp"],
    //   "sig": request.data.,
    //   "tx": request.resolveTransaction(abis, signer, ctx),
    //   "rbn": data["rbn"],
    //   "rid": data["rid"],
    //   "ex": data["ex"],
    //   "req": data["req"],
    // }),
    // );

    // return response.body;
  }
}

class AnchorLink {
  static const String telosChainId =
      "4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11";

  static const String telosEndpoint = "https://node.hypha.earth";

  final actor;
  final privateKey;
  final String? linkKey;
  final String? linkName;
  final String? linkChannel;

  AnchorLink({
    required this.actor,
    required this.privateKey,
    this.linkKey,
    this.linkName,
    this.linkChannel,
  });

  factory AnchorLink.fromExistingSession(actor, privateKey,
      {linkKey, linkName, linkChannel}) {
    return AnchorLink(
      actor: actor,
      privateKey: privateKey,
      linkKey: linkKey,
      linkName: linkName,
      linkChannel: linkChannel,
    );
  }

  static Future<AnchorLink> fromIdentityRequest(
    String requestUri,
    String actor,
    String privateKey, {
    String chainId = AnchorLink.telosChainId,
    bool withSocket = true,
  }) async {
    SigningRequestManager request = SigningRequestManager.from(
      requestUri,
      options: defaultSigningRequestEncodingOptions(
        nodeUrl: AnchorLink.telosEndpoint,
      ),
    );

    if (!request.isIdentity()) {
      throw 'expected identity request';
    }

    // forwarder address generated by dapp to verify passed identity proof
    final callbackUrl = request.data.callback;

    // public request key generated by dapp to encrypt subsequent requests
    final requestKey = request.data.info
            .singleWhere((keypair) => keypair.key == 'request_key',
                orElse: () => null)
            ?.value ??
        "";

    // uuid generated by dapp to identify transport channel
    final sessionName = request.data.info
            .singleWhere((keypair) => keypair.key == 'session_name',
                orElse: () => null)
            ?.value ??
        "";

    // when request key and session name are provided subsequent requests can be listened via websockets
    final supportedSocket = requestKey.isNotEmpty && sessionName.isNotEmpty;

    // identity proof is expected to contain signature of user
    final signer = Authorization()
      ..actor = actor
      ..permission = "active";

    // json.decode(signingRequestAbi) will be used as default abi for identity request
    final abis = <String, dynamic>{};

    // transaction context is ignored for identity request
    final ctx = TransactionContext();

    // final payload = CallbackPayload();

    ResolvedSigningRequest resolvedRequest = request.resolve(abis, signer, ctx);

    // final publicKey =
    //     EOSPrivateKey.fromString(privateKey).toEOSPublicKey().toString();

    // print("sign transaction by $publicKey");

    // ESRConstants.ChainIdLookup[ChainName.TELOS]

    // final Uint8List message = Uint8List.fromList([
    //   ...hex.decode(chainId),
    //   ...resolvedRequest.serializedTransaction,
    //   ...List.filled(32, 0),
    // ]);

    final Uint8List message = Uint8List.fromList(
      List.from(stringToHex(chainId))
        ..addAll(resolvedRequest.serializedTransaction)
        ..addAll(
          Uint8List(32),
        ),
    );

    Map<String, String> callbackPayload = {
      // signer authority
      "sa": actor,
      // signer permission
      "sp": "active",
      // signature proof
      "sig": EOSPrivateKey.fromString(privateKey).sign(message).toString(),
      // transaction id
      "tx": resolvedRequest.getTransactionId().toLowerCase(),
      // reference block number
      "rbn": resolvedRequest.transaction.refBlockNum.toString(),
      // reference block id
      "rid": resolvedRequest.transaction.refBlockPrefix.toString(),
      // expiration time
      "ex": resolvedRequest.transaction.expiration.toString(),
      // original signing request
      "req": requestUri,
      // chain id
      "cid": chainId,
    };

    if (withSocket && supportedSocket) {
      // wallet receive key
      callbackPayload["link_key"] =
          EOSPrivateKey.fromString(privateKey).toEOSPublicKey().toString();
      // persistent wallet channel url
      callbackPayload["link_ch"] = callbackUrl;
      // arbitrary channel name
      callbackPayload["link_name"] = sessionName;
    } else {
      // when link fields are missing following transactions will be handled with qr code too
    }

    await post(Uri.parse(callbackUrl), body: jsonEncode(callbackPayload));

    return AnchorLink(
      actor: actor,
      privateKey: privateKey,
      linkKey: callbackPayload["link_key"].toString(),
      linkName: callbackPayload["link_name"].toString(),
      linkChannel: callbackPayload["link_ch"].toString(),
    );
  }

  Future<String> _decrypt(encrypted) async {
    // 1. Derive shared secret using wallet private key and dapp public key

    final sharedSecretAlgorithm = X25519();

    final sharedSecret = await sharedSecretAlgorithm.sharedSecretKey(
      keyPair: await sharedSecretAlgorithm.newKeyPairFromSeed(
        EOSPrivateKey.fromString(privateKey).d,
      ),
      remotePublicKey: encrypted.publicRequestKey,
    );

    final sharedSecretBytes = await sharedSecret.extractBytes();

    // 2. Decrypt the message using shared secret

    final decryptAlgorithm = AesCbc.with256bits(
      macAlgorithm: Hmac.sha256(),
    );

    final requestUri = await decryptAlgorithm.decrypt(
      encrypted,
      secretKey: SecretKey(sharedSecretBytes),
    );

    return requestUri.toString();
  }

  Stream<String> listenSocketRequests() {
    final channel = IOWebSocketChannel.connect("ws://$linkChannel/$linkName");

    return channel.stream.asyncMap((event) => _decrypt(event));
  }

  void resolveCallback(String requestUri) {
    final request = SigningRequestManager.from(requestUri);

    final callbackUrl = request.data.callback;

    final signer = Authorization()
      ..actor = actor
      ..permission = "active";

    final abis = <String, dynamic>{};

    // transaction context is ignored for identity request
    final ctx = TransactionContext();

    ResolvedSigningRequest resolvedRequest = request.resolve(abis, signer, ctx);
  }

  Future resolve(String request) async {
    final client = EOSClient(AnchorLink.telosEndpoint, 'v1');

    final options =
        defaultSigningRequestEncodingOptions(nodeUrl: AnchorLink.telosEndpoint);

    final esr = SigningRequestManager.from(request, options: options);

    final callback = esr.data.callback;

    final signer = Authorization()
      ..actor = actor
      ..permission = "active";

    final info = await client.getInfo();

    final refBlock = await client.getBlock((info.headBlockNum - 3).toString());

    final abis = await esr.fetchAbis(abiProvider: options.abiProvider);

    final ctx = TransactionContext(
      blockNum: refBlock.blockNum,
      expireSeconds: 30,
      refBlockNnum: refBlock.blockNum,
      refBlockPrefix: refBlock.refBlockPrefix,
      timestamp: refBlock.timestamp,
    );

    final resolved = esr.resolve(abis, signer, ctx);

    final payload = {
      // signer authority
      "sa": actor,
      // signer permission
      "sp": "active",
      // signature proof
      "sig": EOSPrivateKey.fromString(privateKey)
          .sign(resolved.serializedTransaction)
          .toString(),
      // transaction id
      "tx": resolved.getTransactionId().toLowerCase(),
      // reference block number
      "rbn": resolved.transaction.refBlockNum.toString(),
      // reference block id
      "rid": resolved.transaction.refBlockPrefix.toString(),
      // expiration time
      "ex": resolved.transaction.expiration.toString(),
      // original signing request
      "req": request,
      // chain id
      "cid": resolved.request.data.chainId ??
          ESRConstants.ChainIdLookup[ChainName.TELOS],
    };

    await post(Uri.parse(callback), body: jsonEncode(payload));
  }
}
